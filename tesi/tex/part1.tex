
\part{Competitive Landscape}

\chapter{A Brief Introduction}
% If a strong
% mainstream standard for object oriented querying can be reached, SQL will lose ground.
% This will happen for sure, the question is, how long it will take.
	\emph{
		``While familiar on desktops and servers, databases are a recent arrival to embedded systems. 
		Like any organism dropped into a new environment, databases must evolve. 
		A new type of DBMS, the in-memory database system (IMDS), represents the latest 
		step in DBMSes' adaptation to embedded systems'' 
	}\cite{Graves}.
	
	In this chapter we are going to make a brief introduction to the in-memory databases, explaining what they are, their use, their strength and weakness.
	
	\section{Definition}
		An in-memory database (IMDB), also called main memory database (MMDB), 
		in-memory database system (IMDS) or real-time database (RTDB), 
		is a database management system	that relies on main memory for data storage. 
		While the bandwidth of hard disks is just 1 order of magnitude slower than the 
		main memory's bandwidth, the disk access time is about 3 order of magnitude 
		slower than the RAM access time, and thus in-memory databases can be much more faster 
		than traditional database management systems (DBMS).
		
	\section{History}
		Initially embedded systems developers produced their own data management solutions. 
		But with the market competition requiring smarter devices, applications with 
		expanding feature set will have to manage increasingly complex data structures. 
		As a consequence, these data 
		management solutions were outgrowing, and became difficult to maintain and extend. 
		
		Therefore embedded systems developers turned to commercial databases. But the first 
		embedded databases were not the ideal solution. They were traditional DBMS with
		complex caching logic to increase performance, and with a lot of unnecessary features 
		for the device that make use of embedded databases. Furthermore these features cause 
		the application to exceed available memory and CPU resources.
		
		In-memory databases have emerged specifically to meet the performance needs 
		and resource availability in embedded systems.
		
	\section{Application Scenario}
		Often in-memory databases run as embedded database, but it's not their only use.
		Thanks to their high performance, these databases are particularly useful
		for all that kind of applications that need fast access to the data. Some examples:
		
		\begin{itemize}
			\item real time applications which don't need to be persisted either because it doesn't change, 
			or the data can be reconstructed: imagine a routing table of a router with millions of 
			record and data access in less than few milliseconds; the routing table can 
			be rebuilt\cite{Fowler}.
			\item real time applications with durability needs which capture, analyze and respond
			intelligently to important events, requiring high performance in terms of throughput and mainly 
			latency (traditional DBMS can be clustered to increase the througput, but with no great 
			benefits in terms of latency). Infact almost all IMDBs can 
			be persistent on disk while still keeping higher performance compared to 
			traditional DBMSs.
			\item in-memory databases are also very useful for developers of traditional database 
			systems for testing purpose: in a enterprise application running a test suite can take 
			long; switching to an IMDB can reduce the whole build time of the application.		
		\end{itemize}
		
	\section{Comparison against Traditional DBMS}
		In-memory databases eliminate disk I/O and exist only in RAM, but they are not simply a 
		traditional database loaded into main memory. Linux systems already have the
		capability to create a RAM disk, a file system in main memory. But a traditional 
		database deployed in a such virtual hard disk doesn't provide the same benefits of a 
		pure IMDB. In-memory databases are less complex than a traditional DBMS fully deployed 
		in RAM, and lead to a minor usage of CPU and RAM.
		
		Comparing IMDBs with traditional databases we can find at least 3 key 
		differences:	

		\begin{itemize}
			\item Caching.
			\item Data-transfer overhead.
			\item Transaction processing.
		\end{itemize}
			
		\subsection{Caching}
			All traditional DBMS software incorporates caching mechanisms to keep 
			the most used records in main memory to reduce the performance issue 
			introduced by the disk latency. The removal of caching brings to 
			the elimination	of the following tasks:	
					
			\begin{itemize}
				\item cache synchronization, used to keep the portion of the database loaded
				in main memory consistent with the physical database image.
				\item cache lookup, a task that handle the cached page, determining if the
				data requested is in cache
			\end{itemize}
			
			Therefore, removing the cache, IMDBs eliminate a great source of complexity and 
			performance overhead, reducing the work for the CPU and, comparing to a traditional 
			DBMS fully deployed in main memory, also the RAM.
			
		\subsection{Data-Transfer Overhead}
			Traditional DBMS adds a remarkable data transfer overhead due 
			not only to the DB cache, but to the file system and its cache too. 
			In contrast an IMDBs, which eliminate these steps, have little or no data transfer. 
			
			There is also no need for the application to make a copy of the data in local memory, 
			because IMDBs give to the application a pointer to the data that reside in the database.
			In this way the data is accessed through the database API that protect the data itself.
			
		\subsection{Transaction Processing}
			In an hard-disk database the recovery process, from a disaster or a transaction abort, 
			is based on a log file, updated every time a transaction is executed.
			To provide transactional integrity, IMDBs mantain a before image of the objects updated and in case 
			of a transaction abort, the before image are restored in a very efficient way.
			Therefore another complex, memory-intensive task is eliminated from the IMDB, 
			unless the need to add durability to the system, because there is no reason 
			to keep transaction log files.
			
	\section{ACID Support: Adding Durability} \label{durability}
		When we choose a database we expect from it to provide ACID support: atomicity, consistency, 
		isolation and durability. While the first three features are usually supported by in-memory 
		databases, pure IMDBs, in their simplest form, don't provide durability: 
		main memory is a volatile memory and loses all stored data during a reset. 
		
		With their high performance, IMDBs are a good solution for time-critical 
		applications, but when the durability need arises they may not seem a proper
		solution anymore.	To achieve durability\cite{Gorine}, 
		in-memory database systems can use several solutions:
		
		\begin{itemize}			
			\item On-Line Backup. 
			\item Transaction logging.
			\item High availability implementations.	
			\item Non volatile RAM (NVRAM).
		\end{itemize}	
		
		\subsection{On-Line Backup}
			On-line backup is a backup performed while the database is on-line 
			and available for read/write. This is the simplest solution,
			but offer a minimum degree of durability.
		
		\subsection{Transaction Logging}
			A transaction log is a history of actions executed by a database 
			management system. To guarantee ACID properties over crashes or hardware 
			failures the log must be written in a non-volatile media, usually an hard disk. 
			If the system fails and is restarted, the database image can be restored from 
			this log file. 
			
			The recovery process acts similarly to traditional DBMS with a roll-back 
			or a roll-forward recovery. Checkpoint (or snapshot) can be 
			used to speed up this process. However this technique implies the usage 
			of persistence memory such as an hard disk, that is a bottleneck, 
			especially during the resume of the database.
			
			Although this aspect, IMDBs are still faster than traditional DBMS:
			
			\begin{enumerate}
				\item transaction logging requires exactly one write to the file system,
				while disk-based databases not only need to write on the log, but also the data 
				and the indexes (and even more writes with larger transactions).
				\item transaction logging may be usually set to different level of transaction 
				durability. A trade-off between performance and durability is allowed by 
				setting the log mechanism to be synchronous or asynchronous.
			\end{enumerate}
			
		\subsection{High Availability Implementation}
			High availability is a system design protocol and associated 
			implementation: in this case it is a database replication, 
			with automatic fail over to an identical standby database.	A replicated 
			database consists of failure-independent nodes, making sure data is not lost even
			in case of a node failure. This is an effective way to achieve database transaction 
			durability.
			
			In a simile way to transaction logging, a trade-off between performance and durability 
			is achieved by setting the replication as eager (synchronous) or lazy (asynchronous).
			
		\subsection{NVRAM}
			To achieve durability a IMDB can support non volatile ram (NVRAM):
			usually a static RAM backed up with battery power, or some 
			sort of EEPROM. In this way the DBMS can recover the data also after a reboot.
			
			This is a very attractive durability option for IMDBs. NVRAM in contrast to 
			transaction logging and database replication does not involve disk I/O latency 
			and neither the communication overhead.
			
			Despite this, vendors rarely provide support for this technology.
			One of the major problems to this approach is the limited 
			write-cycles of this kind of memory, such as a flash memory. 	
			On the other hand there is some new memory device that has 
			been proposed to address this problem, but the cost of such 
			devices is rather expensive, in particular considering the huge 
			amount of memory needed by IMDBs.

\chapter{In-Memory Database Overview}
	There is a variety of in-memory database systems which can be used to maintain a 
	database in main memory, both commercial and open source. Although all of them share the capability 
	to maintain the database in main memory, they offer different sets of feature. 
	
	In this chapter we will make a competitive landscape of the most famous in-memory databases.
	%In this chapter we will analyze the most popular IMDBs, investigating 
	%their advantages and disadvantages, the stability and reliability of the project 
	%and how much development is going on. Eventually we will go to the development stage and, 
	%in some case, we will also have a look "under the hood" to see how the DB works.
	
	\section{The Analysis' Structure}
	Every in-memory database will be analyzed investigating 
	their advantages and disadvantages, the stability and reliability of the project 
	and how much development is going on. Eventually we will go to the development stage and, 
	in some case, we will also have a look "under the hood" to see how the DB works.
	
	Although not all in-memory database systems share the same features, in terms of advantages and disadvantages, it is possible to identify a subset of common advantages and disadvantages they all have. We will therefore enunciate these common features before starting the specific analysis for each IMDB.
	
	\subsection{Common Advantages}
	The common advantages in-memory database systems share are:
	
	\begin{description}
		\item[Lightweigth] is one of the common advantages IMDBs share. This kind of databases is really simple: they 
		don't implement any of the complex mechanism used by traditional database to speed up the disk I/O. Thus, 
		usually, an in-memory database consist of a simple jar, whose size is less than 1 MB. 
		\item[Robustness] is a direct consequence of the previous point: (citing Henry Ford) it is impossible to 
		break something that doesn't exist.
		\item[High Performance] is another common feature for every IMDB, because they all store the whole database 
		in main memory, avoiding disk access.
	\end{description}
	
	\subsection{Common Disadvantages}
	On the other side, all IMDBs require \textbf{high quantity of main memory}. It is larger as the database image increases, 
	but this doesn't mean that every IMDB uses the same RAM quantity for the same database image. A common question 
	is about what may happen when the RAM is not enough. Altought this question is really interesting, generally 
	an IMDB makes the assumption there is always enough main memory to hold the database image.
	
	Furthermore, since in-memory databases rely on main memory, which is a volatile memory, they may \textbf{lose all the stored data} with a power off, unless they don't use proper mechanisms to achieve durability, as already described in paragraph \ref{durability}. 
	
	But these mechanisms, used to add durability to an in-memory database system, make the database's \textbf{startup terribly slow}, because the database image is not stored on the hard disk, or on another persistent memory, and it needs to be reconstruct at every reboot, for example by reading the transaction log file and repeat all the operations executed before the power off.
	
	This issue is always mitigated by the use of database's \textbf{snapshots}, or commits, which store a fixed database image on a persistent memory, avoiding, in the case of a reboot, the reconstruction of the database image from the start of the transaction log file, and therefore saving a lot of time. Although this mechanism if properly used dramatically decreases the database startup time, it is still very \textbf{slow}, and in addition also the snapshot of the database is very slow and furthermore it slows down, if not freeze, the whole database performance during the execution of the snapshot.
	
	\subsection{Common references}
	The source of informations described in the following sections comes from the web, 
	mainly from sourceforge or 
	ohloh.net. Both these web site offer a variety of news such as the size of developer team, the frequency of 
	commits, the date of the last realese, etc. 
	
	Another source is, naturally, the IMDBs' official web site. Although this is a huge source, it 
	cannont be considered impartial. Therefore the following analysis may not be consistent with facts. 
		
		\section{Prevayler}		
		Prevayler is an object persistence library for Java, written in Java. 
		It keeps data in main memory and any change is written to a journal file for system recovery. This is 
		an implementation of an architectural style that is called System Prevalence by the 
		Prevayler developer team. 
		
		% Prevayler is an object prevalence layer, also called prevalence system, providing transparent ... 
		Therefore Prevayler, being an object prevalence layer, provides transparent persistence for 
		Plain Old Java Objects. In the prevalent model, the object data is kept in memory in native, language-specific 
		object format, and therefore avoid any marshalling to an RDBMS or other data storage system. 
		To avoid losing data and to provide durability a snapshot of data is regularly saved to disk and all changes 
		are serialized to a log of transactions which is also stored on disk \cite{Wuestefeld}.
		
		All is based on the Prevalent Hypothesis: that there is enough RAM to hold all business objects in your system. 	
		
			\subsection{Advantages}
			Prevayler is a lightweight java library, just 350 KB, that is extremely simple to use. There is no separate 
			database server to run. With Prevayler you can program with real objects, there is no use of SQL, there is 
			no impedance mismatch such as when programming with RDBMS. Moreover Prevayler doesn't require the 
			domain objects to implement or extend any class in order to be persistent (except \lstinline!java.io.Serializable!, but 
			this is only a marker interface).
			
			It is very fast. Simply keeping objects in memory in their language-specific format is both orders of magnitude 
			faster and more programmer-friendly than the multiple conversions that are needed when the objects are stored 
			and retrieved from an RDBMS. The only disk access is the streaming of the transactions to the journal file that 
			should be about one thousand\footnote{This is what Prevayler team says on their official web site on 
			Mar 26, 2008.} transactions per second on an average desktop computer.
			
			The thread safety is guaranteed. Actually, in the default Prevayler implementation all writes to the 
			system are synchronized. One write at a time. So there's no threading issues at all. Therefore 
			there is no more multithreading issue such as locking, atomicity, consistency and isolation.
			
			Finally Prevayler supports the execution only in RAM, like a pure in-memory database should work. But 
			it can also provide persistence through a journal file, as we described above. Moreover Prevayler 
			supports snapshots of the database's image, which serves to speed up the database's boot, 
			and server replication, enabling query load-balancing and 
			system fault-tolerance \cite{Prevayler}. This last feature is really promising, 
			because in-memory databases suffer the start up 
			process, allowing it to be used in an enterprise application. Althought this feature is not ready yet: 
			see paragraph \ref{server-replication} for further details at page \pageref{server-replication}.
    			
			\subsection{Disadvantages}
			On the other hand of Prevayler's simplicity, there is some restriction due to the fact that only changes 
			are written in the journal file: transaction must be completely deterministic and repeteable in order 
			to recover the state of the object (for instance it's not possible to use \lstinline!System.getCurrentMillis()!).
			
			In addition, when Prevayler is embedded in your application, the only client 
			of your application's data is the application itself \cite{Hobbs}. While deploying Prevayler as a server, 
			the access to the data is still limited to whom who speaks the host 
			language (you can't use another programming language unless you make your own serialization mechanism) and, 
			at the same time, knows the model objects. For all these reasons there are no administration and migration tools.
						
			Another problem is related to the Prevalent Hypothesis. If, for any reason, the RAM is not enough and 
			an object model is 
			swapped out of main memory, Prevayler will become very slow, more than traditional RDBMS's \cite{Miller}. 
			In fact Prevayler doesn't use any mechanism to optimize the disk I/O, such as traditional DBMS's mechanisms 
			(eg: indexing, caching etc.) Anyway this issue belongs to all pure in-memory databases.
					
			\subsection{Project Info}
			Klaus Wuestefeld is the founder and main developer of Prevayler, an open source project. This project 
			started in 2001, from what sourceforge reports, and had a great development until 2005. 
			The community is still active, but the 
			last update is dated at 25/05/2007 when version 2.3 (the latest) was released. The development team is composed 
			of 8 developers, including Klaus Wuestefeld.. The current development status is declared to be production/stable.	
			
			\subsection{Usage}
			In this example, and in all the followings, we are going to use a simple Plain Old 
			Java Object as business object that need to be persisted: \lstinline!Number!. It has one single 
			private field, which is the value of the number itself, and the relative getter and 
			setter methods.
			\begin{lstlisting}[caption={Implementation of the object Number},label={number-object}] 
public class Number{
  private int value;	
  public Number(){}	
  public Number(int value) {
    this.value = value;
  }
  public int getValue() {
    return value;
  }
  public void setValue(int number) {
    this.value = number;
  }	
}
   		\end{lstlisting} 
			
			Prevayler usage is quite different from a traditional RDBMS with JDBC driver. Prevayler is accessed 
			through a native driver, and it acts similarly to a framework: your business objects must implement 
			the interface \lstinline!java.io.Serializable! in order to be persisted (which is only a marker interface); 
			and all modifications to these objects must be encapsulated in transaction objects. Therefore our 
			business object will appear as follow:	
			\begin{lstlisting} 
public class Number implements Serializable { ...
   		\end{lstlisting} 		
			
			\subsubsection{Basic: main memory and transaction logging}	
			This example is about the default Prevayler's usage: how to create an in-memory database 
			without losing durability. This property is achieved with a transaction log file, whose usage 
			is totally transparent.
			To initialize Prevayler Database you need to create a Prevayler, providing it with 
			the directory where you want to save your database, and the object which is going to be saved in 
			this Prevayler database. This step can be compared 
			to a \lstinline!CREATE TABLE! in SQL, but only one object will be saved in your Prevayler database. 
			Therefore, from a RDBMS perspective where the table is a class and each row is one instance, 
			you may want to initialize Prevayler with a \lstinline!List! or a \lstinline!Map! 
			of \lstinline!Number!. Here is an example:
			\begin{lstlisting}
public class Main{
  private static final String DIRECTORY_DB = "numberDB";
  public static void main(String[] args) throws Exception {
    Prevayler prevayler = PrevaylerFactory.createPrevayler(new HashMap<Integer,Number>(),DIRECTORY_DB);		
    new Main().fillPrevaylerDb(prevayler);
    new Main().readPrevaylerDb(prevayler);
  }
  ...
			\end{lstlisting}			
			
			It's important to understand that the state of the object you use 
			to create this database will not be saved in the database itself. To insert any \lstinline!Number! 
			in the database a transaction must be executed:
			\begin{lstlisting} 
private void fillPrevaylerDb(Prevayler prevayler) throws InterruptedException {		
  for (int i = 0; i<100; i++){			
    prevayler.execute(new InsertNumberTransaction(new Number(i)));			
    System.out.println("The value of the number inserted is = "+i);
  }
}
			\end{lstlisting}
		
			The parameter of the method \lstinline!execute! must be a class that extends \lstinline!org.prevayler.Transaction!. 
			Every insert, update or delete (in other words: any write operation) requires to be executed inside a transaction.
			In this particular case this is the the code:			
			\begin{lstlisting} 
public class InsertNumberTransaction implements Transaction{
  private Number number;
  public InsertNumberTransaction(Number number) {
    this.number = number;
  }
  public void executeOn(Object prevalentSystem, Date ignored) {
    Map<Integer,Number> map = (Map<Integer, Number>) prevalentSystem;		
    map.put(number.getValue(), number);		
  }
}			
			\end{lstlisting}

			It's important to note that when you stop the database, and then you restart it, 
			Prevayler will execute all the transactions exactly
	 		the same number of times they were executed before shutting down the process \footnote{This is the reason 
	 		why the transactions must be deterministic}. While a snapshot should avoid this behavior.	
	 		
	 		Finally, reading from Prevayler database is really simple and doesn't require any transaction:
	 		\begin{lstlisting} 
private void readPrevaylerDb(Prevayler prevayler) {
  Map<Integer,Number> map= (Map<Integer,Number>) prevayler.prevalentSystem();
  Set<Integer> keys = map.keySet();
  for (Integer key : keys) {
    Number number = map.get(key);
    System.out.println("Reading the number " + number.getValue());
  }
}		
			\end{lstlisting}
	 		
	 		\subsubsection{Only RAM}
	 		This example show how to make Pervayler run only in main memory, without the writes to the journal file, 
	 		in the case you want a database even faster and you 
	 		don't care for durability or you don't have write permission. There is only one 
	 		line of code which need to be modified to be able to run Prevayler in such a way:	 		
	 		\begin{lstlisting} 
Prevayler prevayler = PrevaylerFactory.createTransientPrevayler(new HashMap<Integer,Number>());
			\end{lstlisting}
			
			Instead of creating a persistent prevayler, you just need to \lstinline!createTransientPrevayler!. 
			You can also decide to create the transient prevayler from a snapshot, and then work only in main memory: 
			really useful for the execution of your test case. But you can't take a snapshot while using 
			transient prevayler, therefore you need to disable the snapshot in your code when switching 
			from the default to the transient prevayler, otherwise a \lstinline!IOException! will raise.

			With this method you have no durability, but it is even faster than the first example, 
			about 10 times faster. And moreover it is more scalable, 
			because there is no more bottleneck caused by the hard disk. 			
	 		
	 		\subsubsection{Server Replication} \label{server-replication}
	 		Prevayler can support also a server replication modality. Also in this case, only a small 
	 		change to the database initialization is needed. Quite obviously you need two different kind of 
	 		initialization: server side and clients side.
	 		
	 		As regards the server, you need to specify the port number and, then, simply create the object 
	 		\lstinline!Prevayler!:
	 		\begin{lstlisting} 
public class MainServer {	
  private static final String DB_DIRECTORY_PATH = "numberReplicaDB";
  private static final int PORT_NUMBER = 37127;	
  public static void main(String[] args) throws Exception {
    PrevaylerFactory factory = new PrevaylerFactory();
    factory.configurePrevalentSystem(new HashMap<Integer,Number>());
    factory.configurePrevalenceDirectory(DB_DIRECTORY_PATH);
    factory.configureReplicationServer(PORT_NUMBER);
    Prevayler prevayler = factory.create();
    ...
    // execute your transactions
    ...
    // The server will continue to listen/run for incoming connections
    ...
  }
}
			\end{lstlisting}
			
			As for the clients, you have to tell Prevayler not only the port number, 
			but the ip address too. Only one line of code changes from the server:
			\begin{lstlisting} 
public class MainReplicant {	
  private static final String DB_DIRECTORY_NAME = "numberDB";
  private static final int PORT_NUMBER = 37127;
  private static final String SERVER_IP = "10.0.2.2";
	
  public static void main(String[] args) throws Exception {
    PrevaylerFactory factory = new PrevaylerFactory();
    factory.configurePrevalentSystem(new HashMap<Integer,Number>());
    factory.configurePrevalenceDirectory(DB_DIRECTORY_NAME);
    factory.configureReplicationClient(SERVER_IP, PORT_NUMBER);
    Prevayler prevayler = factory.create();
    ...
    //execute your transactions
  }
}
			\end{lstlisting}
			
			With this setup, you can stop, restart and add clients without losing your data, 
			and keeping it synchronized with the server and the other clients, 
			apparently without any concurrent exception. But when you try to kill the server, 
			or for any other reason the server stops, while any client is still active this is 
			the message you get: 
			\begin{lstlisting}
The replication logic is still under development.
java.io.EOFException
			\end{lstlisting}
			
			Reading the javadoc comes out that this feature is \emph{reserved for future implementation}. 
			Contacting Prevayler's author, Klaus Wuestefeld, by email, he said this feature 
			will be probably done within the 2009, because he needs it for other projects.
			
		\section{HSQLDB}
HSQLDB is a relational database written in Java. It is based on Thomas Mueller's Hypersonic SQL discontinued project and therefore its name which stands for Hypersonic SQL DataBase. Thomas Mueller then developed a new database system which he called H2 and he closed the Hypersonic SQL project in 2001. Therefore a number of developers, who where using the closed project for their work, got togheter through the internet and formed the HSQLDB development group.

Each hsql database consists of between 2 to 5 files, all named the same but with different extensions, located in the same directory. For example, the database named "test" consists of the following files:
\begin{itemize}
	\item test.properties contains general settings about the database;
	\item test.script contains the definition of tables and other database objects, plus the data for non-cached tables;
	\item test.log contains recent changes to the database;
	\item test.data contains the data for cached tables;
	\item test.backup is a zipped backup of the last known consistent state of the data file.
\end{itemize}

Hsql 1.8.0 is also the database engine in OpenOffice 2.0.
		
			\subsection{Advantages}
HSQLDB is an open source relational Java database and it can run on Java runtime from version 1.1. As for most IMDBs, it is a lightweight library of about 100 kilobytes in the smaller version and 600 kilobytes in another. It has a JDBC driver and supports a large subset of SQL standards and therefore it is quiet easy switch to HSQLDB if you are using another relational DBMS through SQL.

It offers both in-memory and disk based table, therefore it can act as an in-memory database system, which writes on the disk only the change to the database, or as a traditional database system, recording all the data to the hard disk. Hence HSQLDB let you choose the way you prefer to use it and switch easily between them. Obviously the first will be faster, but the second will save a huge amount of time when the database system is restarted.

In addition HSQLDB can work in server and embedded mode, allowing this time too an easy switch between these two modalities. Usually the server mode is used while developing a new application, so saving the time when it is restarted, and then switch to embedded mode for deployment for better performance.

HSQLDB also includes some tools such as a minimal web server, in-memory query and management tools.
			
			\subsection{Disadvantages}
The most important disadvantages is of course that HSQLDB supports only a low transaction isolation level when queries are made from a Java program, the level 0 which means read uncommitted transaction. Therefore the concurrence must be managed inside the Java program. For example HSQLDB can support the SERIALIZABLE isolation level if you write the database access code as public static Java methods and call them as stored procedures.

Another feature to take into consideration if you want to use HSQLDB is that it supports data to a maximum of 8GB, and although for common applications it is a huge value, if we want to use it in enterprise applications it is very often not enough.

Finally it is important to notice how HSQLDB doesn't support a strict level of durability. In fact if the database system is not shutted down nicely, ie by sending the commands \lstinline!CHECKPOINT! or \lstinline!SHUTDOWN! via JDBC connection before killing the process, then occasionally HSQLDB will lose some data changes.

			\subsection{Project Info}
As already explained in the introduction, HSQLDB is based on the hypersonic SQL project and started in 2001. Actually the latest version is 1.8.0.8, released at 30/08/2007. The project is currently in production/stable development status, and the development team which is composed by 34 programmers is still working. In fact we are close to the next release which will be 1.9.0, whose features are already known: an extensive range of new SQL and JDBC capabilities, increased scalability, and better query optimization have been achieved by a rewrite of several internal components and the addition of some major new ones. 
			
			\subsection{Usage}
HSQLDB usage is very simple because it is almost the same of all relational database systems with JDBC drivers. Also in this example, as for Prevayler, we will use the Number object, showed in the listing \ref{number-object}, as an object to be stored and retrieved. While for Prevayler we need a different implementation for the object Number, altougth it is very small, HSQLDB uses a JDBC driver and therefore uses SQL language, and there is no need for a different implementation. 

The default HSQLDB behavior is to take data in main memory and only changes are written to the disk. In the following listing we show how to execute HSQLDB embedded, or in other word in in-process mode:
\begin{lstlisting}[caption={HSQLDB implementation},label={hsqldb-implementation}]
public class Main{	
	private static final String databaseURL="jdbc:hsqldb:file:db/test";
  private static final String username="sa";
  private static final String password="";
  private static final String driver="org.hsqldb.jdbcDriver";    
	private static final String dropTableQuery = "DROP TABLE NUMBER";
	private static final String createTableQuery = "CREATE TABLE NUMBER (number integer)";
	private static final String saveNumberQuery = "INSERT INTO NUMBER VALUES (?)";
	private static final String findNamberQuery = "SELECT * FROM NUMBER WHERE NUMBER=?";

	public static void main(String[] args) throws Exception {
		Class.forName(driver);
		Connection con = DriverManager.getConnection(databaseURL,username,password);		
		createTable(con);
		int numberValue = new Random().nextInt();
		Number number = new Number();
		number.setNumber(numberValue);
		saveNumber(con,number);
		Number numberRetrieved = findNumber(con,numberValue);
		dropTable(con);		
		if (numberRetrieved.getNumber()==number.getNumber())
			System.out.println("The numbers have the same value");
	}	
	private static Number findNumber(Connection con, int numberValue) {
		Number result = null;
		try {
			PreparedStatement st = con.prepareStatement(findNamberQuery);
			st.setInt(1, numberValue);
			ResultSet resultSet = st.executeQuery();
			if (resultSet.next()){
				result = new Number();
				result.setNumber(resultSet.getInt(1));
			}
			System.out.println("Number found correctly");	
		} catch (SQLException e) {
			e.printStackTrace();
		} 	
		return result;
	}
	private static void saveNumber(Connection con, Number number) {
		try {
			PreparedStatement st = con.prepareStatement(saveNumberQuery);
			st.setInt(1, number.getNumber());
			st.executeUpdate();
			System.out.println("Number saved corerctly");
		} catch (SQLException e) {
			e.printStackTrace();
		} 		
	}
	private static void createTable(Connection con) {
		try {
			PreparedStatement st = con.prepareStatement(createTableQuery);
			st.executeUpdate();
			System.out.println("Table created correctly");
		} catch (SQLException e) {
			e.printStackTrace();
		} 	
	}
	private static void dropTable(Connection con) {
		try {
			PreparedStatement st = con.prepareStatement(dropTableQuery);
			st.executeUpdate();
			System.out.println("Table deleted correctly");
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	
}
\end{lstlisting}
The database systems is started directly by the JDBC driver at the first connection, and therefore it runs as an embedded database. This modality provides very high performance and full portability. It's important to point out that after the word "file" in the \lstinline!databaseURL!, there is the path where the files are stored on the disk, which in this case is only a relative path which tells HSQLDB to store the "test" database in the subfolder "db".

It is also possible to execute HSQLDB all in main memory without writing any file to the disk. This is done just by using a different \lstinline!databaseURL!: instead of the word "file" we need to use the word "mem", and then write only the database name:
\begin{lstlisting}
private static final String databaseURL="jdbc:hsqldb:mem:test";
\end{lstlisting}			

		\section{Hxsql}
Hxsql is a quite recent database system written in Java and it is built on HSQLDB, therefore it shares most of the features of HSQLDB and it is fully compatible with the open source version. Also the version numbering is based on the one used by HSQLDB. The idea behind HyperCtremeSQL consists in the capability to replace the HSQLDB jar in an existing application with no change to the Java code or SQL queries.

The main differences with HSQLDB are a new indexing engine and a new persistence core. These changes provides higher performance and make Hxsql to go over some of the limitations of HSQLDB. For example Hxsql is not limited anymore to 8GB of data storage, but by default this limit is now 16GB, which can moreover be extended to 128GB. Furthermore it has also a lower footprint, which now is about 350-400KB. 

Although it seems a better than HSQLDB, which is already a very good database system, its code is closed source and we can't test if the real performance are the same that we read on its home page. Anyway this is a product that need to be mentioned, especially for those who are interested in HSQLDB and in a possible upgrade.

		\section{H2}
H2 is a relational database management system written in Java by Thomas Mueller, who is the same author of HypersonicSQL, the ancestor of HSQLDB, and also, originally, main developer of HSQLDB itself. In fact the name H2 stands for Hypersonic 2, however H2 does not share any code with HypersonicSQL or HSQLDB. 
		
			\subsection{Advantages}
This is an open source database written in Java, and it is built from scratch, without sharing any code with Hsql. Therefore this database system benefits from all the experience cumulated by Mueller with his previous work.

H2 is able to create both in-memory tables, as well as disk-based tables. Therefore tables can be temporary or persistent on a durable device. 

As regards the administration tools, H2 includes an embedded web server and a browser based console, in order to support the portability of the database system.

In addition, H2 implements a simple form of high availability: when used in client-server mode, the database engine supports hot failover (commonly known as clustering). However, the clustering mode must be re-enabled manually after a system failure.

			\subsection{Disadvantages And Project Info}
Although this database systems is reach of interesting features, it is quite recent, in fact the project started in May 2004, but it was first published in December 2005. In fact the latest stable release is the 1.0.79, while there is also a beta release, whose version number is 1.1.104. 

Another disadvantage is that there is only one developer: Thomas Mueller. Moreover H2 is only a Mueller's hobby, therefore the project still don't has a good support. 

			\subsection{Usage}
H2 is able to run both in embedded mode and in server mode, allowing, in this second modality, the clustering of more servers, and therefore the high availability. We will show both of this modality in the following example. Also in this example, as for Prevayler, we will use the Number object, showed in the listing \ref{number-object}, as an object to be stored and retrieved.

				\subsubsection{Embedded Mode}
The implementation for H2 to run in embedded mode is almost equal to the implementation of HSQLDB, showed in the listing \ref{hsqldb-implementation}. It's not by chance that the author of H2 was also main developed at HSQLDB project. There are only two differences: the database URL and, obviously, the JDBC driver used to connect to the database. The following example shows these two differences:
\begin{lstlisting}
public class Main{
	
    private static final String databaseURL="jdbc:h2:file:db/test";
    private static final String username="sa";
    private static final String password="";
    private static final String driver="org.h2.Driver";

    ...
}
\end{lstlisting}
								
				\subsubsection{Clustering / High Availability Mode}

H2 supports a simple clustering / high availability mechanism. The architecture of a clustering mode is composed by two database servers, which run on two different computers, and on both computers there is a copy of the same database. If both servers run, each database operation is executed on both computers. If one server fails (power, hardware or network failure), the other server can still continue to work. From this point, the operations will be executed only by one server until the other server is restored. Clustering can only be used in server mode (the embedded mode does not support clustering). It is possible to restore the cluster without stopping the server, however it is critical that no other application is changing the data in the first database while the second database is restored, so restoring the cluster is currently only a manual process.

In this example the two databases reside on the same computer, but we will use them as they were on two different machines, and therefore with remote access (we will not use localhost as an address to connect to the database). The following steps describe how to make it runs in clustering mode:
\begin{enumerate}
	\item We need to create 2 different directories, server1 and server2, that will store our databases.
	\item To start the first server we need to use the following command: 
\begin{lstlisting}[commentstyle=\color{black}]
java -cp h2.jar org.h2.tools.Server -tcp -tcpAllowOthers -tcpPort 9101 -baseDir server1
\end{lstlisting}
The option "-cp" specifies the classpath to h2.jar, if it's not in the CLASSPATH, and the option -baseDir specifies the path to the directory where your server will store the database.
	\item Subsequently we need to start the second server with the following command:
\begin{lstlisting}[commentstyle=\color{black}]
java -cp h2.jar org.h2.tools.Server -tcp -tcpAllowOthers -tcpPort 9102 -baseDir server2
\end{lstlisting}
	\item After the two server are running, we need to use the "CreateCluster" tool to initialize the cluster. This will automatically create a new, empty database if it does not exist. The command is the following: 	
\begin{lstlisting}[commentstyle=\color{black}]
java -cp h2.jar org.h2.tools.CreateCluster -urlSource jdbc:h2:tcp://192.168.150.151:9101/test -urlTarget jdbc:h2:tcp://192.168.150.151:9102/test -user sa -serverlist 192.168.150.151:9101,192.168.150.151:9102
\end{lstlisting}
	\item It is now possible to connect to the databases using the following JDBC URL: 
\begin{lstlisting}[commentstyle=\color{black}]
jdbc:h2:tcp://192.168.150.151:9101,192.168.150.151:9102/test
\end{lstlisting}
\end{enumerate}

This clustering mode can now be tested simply by using the example code of the embedded modality and only changing the database URL. Now H2 is providing high availability and you can also stop one server (by killing the process), without noticing any issue, because the other server is still running, and therefore the database is still accessible. Although this works, when a server crash, to restore the cluster, you first need to delete the database that failed, then restart the server that was stopped, and re-run the CreateCluster tool. 
			
		\section{Db4o}
Db4o, database for objects, is an high-performance, embeddedable open source object database for Java and .NET developers. It is developed, commercially licensed and supported by db4objects, Inc., which is a privately-held company based in San Mateo, California. The company was incorporated in 2004 under CEO Christof Wittig, with the financial backing of top-tier Silicon Valley investors including Mark Leslie, founding CEO of Veritas, Vinod Khosla, founding CEO of SUN Microsystems, and Jerry Fiddler, founding CEO of Wind River.

 

		
			\subsection{Advantages}
Db4o is an open source database system with a small footprint and it is much more faster than traditional relational database management systems. Object persistence is easy with db4o, it can be done with only 1 line of code. 

It can run both in embedded and server mode and it can store the data on the disk or keep them all in main memory only. And since Db4o supports both Java and .Net, it is possible to access the same database from these 2 different platforms. 

In addition db4o supports automatic object schema evolution for the basic class model changes (field name deletion/addition). More complex class model modifications, like field name change, field type change, hierarchy move are not automated out-of-the box, but can be automated by writing a utility update program.

Rather than using string-based APIs, such as SQL, native queries allow developers to simply use the programming language itself (e.g., Java, C\#, or VB.NET) to access the database and thus avoid a constant, productivity-reducing context switch between programming language and data access API.
		
			\subsection{Disadvantages}
Db4o can run both as in-memory database system or as a disk based database, but it doesn't have an in-memory mode with some form of durability (e.g. with a transaction log file). Moreover the in-memory mode is not so much more performant than the disk based mode. 

For some native queries db4o will have to instantiate some of the persistent objects to run the native query code, thus slowing down the database's performance. 

There's not much "out-of-the-box-support" for clustering several db4o-databases at the moment. There's a simple query-a-cluster-implementation in com.db4o.cluster which could guide you only as a starting point.
			
			\subsection{Project Info}
This project started in 2000 and it is continuously updated: there is also a continuous build available for download every day. The latest version is the 7.6 and the number of developers working at this project are about 20.

According to db4o community website the amount of registered members has grown to over 45000 providing various sources of documentation: tutorial, reference documentation, API documentation, online paircasts and blogs.

			\subsection{Usage}


Also in this example, as for Prevayler, we will use the Number object, showed in the listing \ref{number-object}, as an object to be stored and retrieved. In the following code we can see how it is easy to use Db4o:

\begin{lstlisting}
public class Main {

	private static final String databaseFileName = "test";

	public static void main(String[] args) throws Exception {
		ObjectContainer db = createEmptyDB();
		fillDB(db);
		simpleQuery(db);
		nativeQuery(db);
		db.close();
	}

	private static void nativeQuery(ObjectContainer db) {
//		List<Number> numberList = db.query(new NumberPredicate());
		List<Number> numberList = db.query(new Predicate<Number>() {
			public boolean match(Number candidate) {
				return candidate.getNumber() > 2;
			}
		});
		for (Number number : numberList)
			System.out.println(number.getNumber());
	}

	private static void simpleQuery(ObjectContainer db) {
		ObjectSet<Number> numbers = db.queryByExample(new Number(2));
		while (numbers.hasNext())
			System.out.println(numbers.next().getNumber());
	}

	private static void fillDB(ObjectContainer db) {
		db.store(new Number(1));
		db.store(new Number(2));
		db.store(new Number(2));
		db.store(new Number(3));
		db.store(new Number(4));
	}

	private static ObjectContainer createEmptyDB() {
		new File(databaseFileName).delete();
		ObjectContainer db = Db4o.openFile(databaseFileName);
		return db;
	}

}

\end{lstlisting}
			
Note that the Number class here does not require any interface implementations, annotations or attributes added. It can be just any application class including third-party classes contained in referenced libraries. All field objects (including collections) are saved automatically. This feature speed up the whole process of developing an application, because the persistence layer become very easy both to write and change.

The example previously showed described how to run Db4o in a disk based mode, but if we want to execute it all in main memory, we need to change just few lines of code during the creation of the database, as reported in the following code:

\begin{lstlisting}
Configuration configuration = Db4o.newConfiguration();
MemoryIoAdapter memoryIoAdapter = new MemoryIoAdapter();
configuration.io(memoryIoAdapter);
ObjectContainer db = Db4o.openFile(configuration,databaseFileName);
\end{lstlisting}
				
Note that Db4o by default has not high performance in read operations. If you want to speed them up you can use an index, like a relational database system. The following code shows how it is possible to create an index based on the field called "number":
		
\begin{lstlisting}
configuration.objectClass(Number.class).objectField("number").indexed(true);
\end{lstlisting}		
		
		\section{Derby}
		asdasd

		
			\subsection{Advantages}
asdasd
			
			\subsection{Disadvantages}
asdasd
			
			\subsection{Project Info}
asdasd
		
		\section{SQLite}
		asdasd

		
			\subsection{Advantages}
asdasd
			
			\subsection{Disadvantages}
asdasd
			
			\subsection{Project Info}
asdasd
		
		\section{Firebird}
		asdasd

		
			\subsection{Advantages}
asdasd
			
			\subsection{Disadvantages}
asdasd
			
			\subsection{Project Info}
asdasd
				
		\section{MySql}
		asdasd

		
			\subsection{Advantages}
asdasd
			
			\subsection{Disadvantages}
asdasd
			
			\subsection{Project Info}
asdasd
		
		\section{ExtremeDB}
	    * Closed source
    * ACID-compliant
    * Designed for embedded systems and applications with real-time performance requirements
    * eXtremeDB provides a code footprint as small as 50K
    * eXtremeDB offers a SQL API, called eXtremeSQL
    * eXtremeDB High Availability Edition is designed to ensure that changes to a master database and identical standby databases succeed or fail together, and enables deployment of multiple fully synchronized eXtremeDB-HA databases
    * Cross-platform
    * Typical eXtremeDB users are software developers creating applications in the C and C++ languages
    * The latest release is 3.0 and date to 03/04/2006 
		
		\section{Polyhedra}
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		
		\section{TimesTen}
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		
		\section{Csql}
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		
		\section{SolidDB}
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		
		\section{MonetDB}
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		
		\section{RDM Embedded}
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		
		\section{FastDB}
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		
		\section{QuiLogic}
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		
		\section{Pico4v2}
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		intorDB intorDB intorDB intorDB intorDB intorDB intorDB 
		
		\section{Conclusion}
		Tabular result here!